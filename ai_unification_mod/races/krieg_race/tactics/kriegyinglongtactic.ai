----------------------------------------
-- File: 'kriegyinglongtactic.ai'
-- Edited by Thudmeizer @ 18.08.2024

class 'KriegYingLongTactic' (KriegVehicleTactic)

KriegYingLong = {}

function KriegYingLongTactic:__init( squad_ai ) super( squad_ai )

	self:SetName("Krieg Ying Long Tactic")

	-- Assume aircraft just entrenched/retrenched
	self.m_iLastEntrenchTime = g_iGMT
	self.entrenchAttempt = g_iGMT

	-- Get the type we have
	self.isFlyingVersion = self.squad_ai:GetSquadName() == "krieg_squad_yinglong"
	-- Get ID and loaded status for the NEW flying AIRCRAFT, and if it was previously loaded
	if self.isFlyingVersion then
		if AIRCRAFT_FlyingID == nil or self.squad_ai:GetID() ~= AIRCRAFT_FlyingID then
			AIRCRAFT_IsLoaded = false
			AIRCRAFT_FlyingID = self.squad_ai:GetID()
		end
	end

	--Vehicle is a light transport. New AI implemented for flying transports.
	self.m_iTransportVehicle = 1
	self.iAIRCRAFTTransportSlots = 2
	self.iAIRCRAFTUsedTransportSlots = 0

	-- Used for the stuck check code for the squads that can jump
	self.initialPosition = self.squad_ai:GetPosition()

	-- Check repair status
	self.m_bNeedRepair = false
end

function KriegYingLongTactic:InitAbilities()

	-- Init ability ID's
	if (KriegYingLong.land_id == nil or KriegYingLong.takeoff_id == nil) then
		KriegYingLong.land_id = cpu_manager.stats:GetAbilityID("krieg_vulture_land")
		KriegYingLong.takeoff_id = cpu_manager.stats:GetAbilityID("krieg_vulture_takeoff")
		KriegYingLong.bomb_id = cpu_manager.stats:GetAbilityID("krieg_incendiary_bombs")
	end
end

function KriegYingLongTactic:DoAbilities()

	-- Try to use incendiary bombs based on target type
	if self.squad_ai:IsInCombat() then
		-- Check if we're in close combat - to Use Incendiary
		if self.squad_ai:CanDoAbility(KriegYingLong.bomb_id) and not self.squad_ai:IsInStateMove() then
			local oPos = self.squad_ai:GetPosition()
			local oEnemySquad = Ability.Filters.CloseInfantryEnemy(oPos, 20, 1)
			local oEnemySquadB = Ability.Filters.CloseMonsterEnemy(oPos, 20, 1)
			if oEnemySquad ~= nil and not oEnemySquad:IsBroken() then
				local oEnemyPos = oEnemySquad:GetPosition()
				oPos.x = oPos.x + 2*(oEnemyPos.x - oPos.x)
				oPos.z = oPos.z + 2*(oEnemyPos.z - oPos.z)
				self.squad_ai:DoMove(oPos)
				self.squad_ai:DoSpecialAbility(KriegYingLong.bomb_id)
				return
			elseif oEnemySquadB ~= nil and not oEnemySquadB:IsBroken() then
				local oEnemyPos = oEnemySquadB:GetPosition()
				oPos.x = oPos.x + 2*(oEnemyPos.x - oPos.x)
				oPos.z = oPos.z + 2*(oEnemyPos.z - oPos.z)
				self.squad_ai:DoMove(oPos)
				self.squad_ai:DoSpecialAbility(KriegYingLong.bomb_id)
				return
			end
		end
	end
--[[
	-- Transportation code
	if not self.isFlyingVersion and (not self.squad_ai:IsInCombat() and (self:GetState() == "Hold" or not self:IsMoving())) then
		-- Check for nearby squads
		local oFunctor = function(oSquad, iCount)
			return oSquad:GetNumTroopers() > iCount and not ((oSquad:IsInStateMove() or oSquad:IsInCombat()))
		end
		local eSquad = cpu_manager:GetClosestSquad(self.squad_ai:GetPosition(), 20, oFunctor, 6)
		if eSquad ~= nil then
			print(eSquad:GetSquadName())
		end
	end
	print(self.squad_ai:IsIdle())
	print(self.squad_ai:CanUnload())
	print(self.squad_ai:GetID())
]]

	-- Try to entrench first
	self:DoEntrenchAbility()

	-- If TOO damaged, retreat
	if g_iGMT > self.entrenchAttempt + 3 then
		if self.isFlyingVersion and self.squad_ai:GetHealthPercentage() < 0.3 then
			self:SetState(Tactic.States.Retreat)
			Tactic.SetState(self, self:GetState())
			self:BeginRetreatState()
			cpu_manager:DoMove(self.squad_ai, cpu_manager.start_pos, false, "RetreatState Vehicle")
		end
	end

    -- Jump squads' unstuck code call. Put ANYWHERE in the DoAbilities() function
    -- Checks jump-able stuck squads, and force them to jump nearby
	if self.isFlyingVersion then
		if self.squad_ai:CanJump() then
			self:SolveStuckCase()
		end
	end
end

function KriegYingLongTactic:DoEntrenchAbility()

	-- Unload troops immediately, since it is not implemented yet
	if not self.isFlyingVersion and self.squad_ai:CanUnload() then
		self.squad_ai:DoUnload()
	end

--[[ 
	-- Don't land/takeoff too fast after last attempt. Disabled, not needed.
	if (g_iGMT < self.m_iLastEntrenchTime + 30) then
		return
	end
]]

	local health = self.squad_ai:GetHealthPercentage()

-- Disabled as flier does not land at start_pos due to being held by standard vehicle repair code after retreat. Flier gets repaired regardless at start_pos due to being normal vehicle
--[[
	-- Check if we have to land back at start_pos to be repaired, because of low health
	if self.isFlyingVersion and ((health < 0.5 and not self.squad_ai:IsInCombat()) or health < 0.25) then
		if self.squad_ai:CanDoAbility(KriegYingLong.land_id) and not (cpu_manager.terrain_analyzer:HasThreat(self.squad_ai:GetPosition(), 35) or self.squad_ai:WasRecentlyHurt()) then
			self:SetState(Tactic.States.Retreat)
			Tactic.SetState(self, self:GetState())
			self:BeginRetreatState()
			cpu_manager:DoMove(self.squad_ai, cpu_manager.start_pos, false, "RetreatState Vehicle")

			-- Check for damaged flying vehicle close to start point then attempt to land to get repaired
			local vSquadPos = self.squad_ai:GetPosition()
			local iDistance = distance_sqr(self.target, vSquadPos)
			if (self.m_bNeedRepair and iDistance < sqr(50) and self.squad_ai:WasRecentlyHurt() and distance_sqr(self.target, cpu_manager.start_pos) < 1) then
				self.squad_ai:DoSpecialAbility(KriegYingLong.land_id)
				self.m_iLastEntrenchTime = g_iGMT
				self.entrenchAttempt = g_iGMT
			end
		end
	end

	-- Check for damaged flying vehicle close to start point then attempt to land to get repaired
	local vSquadPos = self.squad_ai:GetPosition()
	local iDistance = distance_sqr(self.target, vSquadPos)
	if self.isFlyingVersion and ((health < 0.5 and not self.squad_ai:IsInCombat()) or health < 0.25) then
		if self.squad_ai:CanDoAbility(KriegYingLong.land_id) and not (cpu_manager.terrain_analyzer:HasThreat(self.squad_ai:GetPosition(), 35) or self.squad_ai:WasRecentlyHurt()) then
			--if (self.m_bNeedRepair and iDistance < sqr(50) and self.squad_ai:WasRecentlyHurt() and distance_sqr(self.target, cpu_manager.start_pos) < 1) then
			if (iDistance < 200) then
				self.squad_ai:DoSpecialAbility(KriegYingLong.land_id)
				self.m_iLastEntrenchTime = g_iGMT
				self.entrenchAttempt = g_iGMT
			end
		end
	end
]]
	-- Check if we must take off to carry on fighting
	if not self.isFlyingVersion and self.squad_ai:CanDoAbility(KriegYingLong.takeoff_id) then
		if self.squad_ai:WasRecentlyHurt() or health > 0.85 or (health > 0.6 and BuildBaseStrategy:HasRelic())
		or cpu_manager.terrain_analyzer:HasThreat(self.squad_ai:GetPosition(), 35) then
			self.squad_ai:DoSpecialAbility(KriegYingLong.takeoff_id)
		end
	end
end

function KriegYingLongTactic:Update()

	-- State machine
	if (not VehicleTactic.Update( self )) then
		return false
	end

--[[
	if (self:IsComplete()) then
		return
	end

	-- Check if vehicle can be repaired
	if (self.squad_ai:CanBeRepaired() and self.squad_ai:GetNumTroopers() == 1 and not self.squad_ai:IsReinforcing()) then
	
		-- Set repair states
		if (self.squad_ai:IsRanged() and self.squad_ai:GetHealthPercentage() < 0.2) then
			self.m_bNeedRepair = true
		elseif (not self.squad_ai:IsRanged() and not self.squad_ai:WasRecentlyHurt() and self.squad_ai:GetHealthPercentage() < 0.4) then
			self.m_bNeedRepair = true
		end
	end
	
	-- Check if vehicle needs repair
	if (self.m_bNeedRepair) then
			
		-- Check if vehicle is repaired
		aitrace("Current repair target = "..tostring(self.target.x)..", "..tostring(self.target.z))
		if (self.squad_ai:GetHealthPercentage() > 0.99) then
	        self.m_bNeedRepair = false
	        self.hurt_level = 0.6
	    end
	end
	
	if (self.squad_ai:CanJump()) then
		self.tolerance_default = self.squad_ai:GetJumpDistance()
	else
		self.tolerance_default = 100
	end
	
	self:Upgrade()
	
	self:Reinforce()
]]
	self:SyncSubState()
	
	-- Check if ranged vehicle under attack wants to retreat a short distance
	self:Retreat()
	
	if (self.stateID == Tactic.StateID.NoState) then
	
		-- Check dance mode
		if (CpuManager.AISettings.iDancing == 2) then
			self:CheckForDance()
			if (self.stateID == Tactic.StateID.NoState) then
				self:CheckForStealthTroops()
			end
		elseif (CpuManager.AISettings.iDancing == 1 and g_iGMT > self.m_iDancing + 10) then
			self:CheckForDance()
			if (self.stateID == Tactic.StateID.NoState) then
				self:CheckForStealthTroops()
			end
		end
	end
	
	-- Special moves
	self:CloseOnEnemy()
	
	-- Do abilities
	self:InitAbilities()
	self:DoAbilities()
	
	-- Don't update stance if in special substate !
	if (self.stateID == Tactic.StateID.NoState) then
		self:UpdateStance()
	end
	return true
end

function KriegYingLongTactic:BeginRetreatState()

	-- Check if we're busy
	if self:IsInSubState() then
		return
	end

	-- Check move delay
	if (g_iGMT < self.m_iMoveDelay + 5 and (self:IsMoving() or self.m_bNeedRepair)) then
		Tactic.SetSubState( self, VehicleTactic.HoldState, "Holding" )
		return
	end

	local vSquadPos = self.squad_ai:GetPosition()
	local iDistance = distance_sqr(self.target, vSquadPos)

--[[ 
	-- Try to unload troops
	if (self:UnloadTroops(iDistance)) then
		self.m_iMoveDelay = g_iGMT - 3
		Tactic.SetSubState(self, self.HoldState, "Holding")
		return
	end

	-- Check for damaged vehicles close to start point
	if (self.m_bNeedRepair and iDistance < sqr(50) and not self.squad_ai:WasRecentlyHurt() and
		distance_sqr(self.target, cpu_manager.start_pos) < 1) then
		
		if ((self.squad_ai:IsInStateAttackMove() or self.squad_ai:IsInStateMove()) and not self:IsMoving()) then
			self.squad_ai:DoStop()
			self.m_iMoveDelay = g_iGMT + 15	
		end
		Tactic.SetSubState( self, VehicleTactic.HoldState, "Holding" )
		return
	end
]]
	
	-- Check distance
	if (iDistance > sqr(50) or not self:IsDefender()) then
	
		-- If we are too far away from the retreat position, then make a basic move
		cpu_manager:DoMove(self.squad_ai, self.target, false, "RetreatState Vehicle")
		
	elseif (iDistance > sqr(25) or self.squad_ai:WasRecentlyHurt()) then
	
		-- If we are in range of the retreat position, then make an attack move
		cpu_manager:DoMove(self.squad_ai, self.target, true, "RetreatState Vehicle")
	else
		self.squad_ai:DoStop()
	end
	self.m_iMoveDelay = g_iGMT

	-- Set holding sub-state
	Tactic.SetSubState( self, VehicleTactic.HoldState, "Holding" )
end

-------------------------------------------------------------------------

--[[ 
-- Too complex to create viable aircraft fliers Transportation code.... Doable, but I gave up.
function KriegYingLongTactic:ReadyToTransport()
	-- Testing....
	if true then return true end
		if self.isFlyingVersion then
			return (not self.squad_ai:WasRecentlyHurt() and self.squad_ai:GetHealthPercentage() > 0.4 and
				not self.squad_ai:IsInCombat() and not cpu_manager.terrain_analyzer:HasThreat(self.squad_ai:GetPosition(), 70))
		else
			return (self.iAIRCRAFTUsedTransportSlots < self.iAIRCRAFTTransportSlots and not self.squad_ai:WasRecentlyHurt() and
				self.squad_ai:GetHealthPercentage() > 0.3 and not self.squad_ai:IsInCombat() and
				not cpu_manager.terrain_analyzer:HasThreat(self.squad_ai:GetPosition(), 50))
		end
	end
end

function KriegYingLongTactic:LoadSquad(oSquad, iSquadStrength)
	if self.isFlyingVersion then
		if self.squad_ai:CanDoAbility(KriegYingLong.land_id) then
			self.squad_ai:DoSpecialAbility(KriegYingLong.land_id)
		end
	else
		-- Update transport data
		self.m_iLoadedTroopStrength = self.m_iLoadedTroopStrength + iSquadStrength
		self.iAIRCRAFTUsedTransportSlots = self.iAIRCRAFTUsedTransportSlots + (OccupiedSlotsDA[oSquad:GetSquadName()] or 1)
		-- Load squad
		-- print(self.iAIRCRAFTUsedTransportSlots)
		--cpu_manager:DoMove(self.squad_ai, oSquad:GetPosition(), false, "Load troops")
		for oEntity in self.squad_ai:GetEntities() do
			oSquad:DoDefault(oEntity)
			break
		end
		self.m_iMoveDelay = g_iGMT - 3
	end
end

function KriegYingLongTactic:UnloadTroops(iDistance)
	-- Check if vehicle has loaded troops
	if self.squad_ai:CanUnload() then
		-- Check if we should unload the troops
		if (self.squad_ai:WasRecentlyHurt() or self.squad_ai:GetHealthPercentage() < 0.4 or self.m_bNeedRepair or
			self.squad_ai:IsInCombat() or (self.squad_ai:IsLocked() and iDistance < sqr(35))) then

			-- Unload all troops
			self.squad_ai:DoStop()
			self.squad_ai:DoUnload()
			self.iAIRCRAFTUsedTransportSlots = 0
			self.m_iLoadedTroopStrength = 0
			return true
		end
		return false
	end
	return false
end
]]

-- Unstuck Code --------------------------------------------------
function KriegYingLongTactic:SolveStuckCase()
	local iPosition = self.squad_ai:GetPosition()
	if iPosition.x ~= self.initialPosition.x or iPosition.z ~= self.initialPosition.z then
	-- NOT stuck, update previous position and return, we are all good
		self.initialPosition = iPosition
		return
	end

	-- If we got here, the squad is NOT moving. See if it is simply waiting, or is stuck!
	local state = self.squad_ai:GetTactic():GetState()
	if (self.squad_ai:IsInStateMove() or self.squad_ai:IsInStateAttackMove() or state == "Attack") and not self.squad_ai:IsInCombat()
	and iPosition.x == self.initialPosition.x and iPosition.z == self.initialPosition.z then
	-- STUCK!!!!! Run the unstuck code
		self:ForceSquadJumpNear(iPosition)
	end
	-- Update previous position anyway
	self.initialPosition = self.squad_ai:GetPosition()
end

function KriegYingLongTactic:ForceSquadJumpNear(pos)
	local iPos = self.squad_ai:GetPosition()
	local vJumpPosition = self.squad_ai:GetPosition()
	local jumpDist = self.squad_ai:GetJumpDistance()
	local jumpDistSqr = jumpDist * jumpDist
	local vDir = cpu_manager:GetDirectionToEnemy(pos)
	-- First, try an unstuck jump TOWARDS the enemy 
	-- Try to jump somewhere near, perform 30 checks in total, for a viable position
	for i = 1, 12 do
		-- Create a jump position
		vJumpPosition.x = pos.x + vDir.x * math.random(10, jumpDist)
		vJumpPosition.z = pos.z + vDir.z * math.random(10, jumpDist)
		-- Check if target position is in range and if unit is able to jump to target position
		local iDistanceSqr = distance_sqr(vJumpPosition, iPos)
		if iDistanceSqr < jumpDistSqr and self.squad_ai:CanJumpToPosition(vJumpPosition) then
			-- Jump to position
			self.squad_ai:DoJump(vJumpPosition)
			self.last_jump = g_iGMT
			self.m_iLastGatherMove = self.last_jump - 10
			return
		end
	end
	-- Then try any random nearby place, as a secondary option
	for i = 1, 18 do
		-- Create a jump position
		vJumpPosition.x = pos.x + 0.7 * math.random(-jumpDist, jumpDist)
		vJumpPosition.z = pos.z + 0.7 * math.random(-jumpDist, jumpDist)
		-- Check if target position is in range and if unit is able to jump to target position
		local iDistanceSqr = distance_sqr(vJumpPosition, iPos)
		if iDistanceSqr < jumpDistSqr and self.squad_ai:CanJumpToPosition(vJumpPosition) then
			-- Jump to position
			self.squad_ai:DoJump(vJumpPosition)
			self.last_jump = g_iGMT
			self.m_iLastGatherMove = self.last_jump - 10
			return
		end
	end
end