----------------------------------------
-- File: 'caestustactic.ai'
-- Edited by Gambit @ 27.02.2019

class 'CaestusTactic' (ImperialFistsVehicleTactic)

IFCaestus = {}

function CaestusTactic:__init( squad_ai ) super( squad_ai )

	self:SetName("Imperial Fists Caestus Tactic")
	
	-- Assume Caestus just entrenched/retrenched
	self.m_iLastEntrenchTime = g_iGMT
	self.entrenchAttempt = g_iGMT

	-- Get the type we have
	self.isFlyingVersion = self.squad_ai:GetSquadName() == "imperial_fists_squad_assault_ram"

	-- Used for the stuck check code for the squads that can jump
	self.initialPosition = self.squad_ai:GetPosition()
end


function CaestusTactic:InitAbilities()
	-- Init ability ID's
	if IFCaestus.land == nil then
		IFCaestus.land = cpu_manager.stats:GetAbilityID("imperial_fists_caestus_land")
		IFCaestus.takeoff = cpu_manager.stats:GetAbilityID("imperial_fists_caestus_takeoff")
	end
end


function CaestusTactic:DoAbilities()

	-- Try to entrench first
	self:DoEntrenchAbility()

	-- If TOO damaged, retreat
	if g_iGMT > self.entrenchAttempt + 3 then
		if self.isFlyingVersion and self.squad_ai:GetHealthPercentage() < 0.3 then
			self:SetState(Tactic.States.Retreat)
			Tactic.SetState(self, self:GetState())
			self:BeginRetreatState()
			cpu_manager:DoMove(self.squad_ai, cpu_manager.start_pos, false, "RetreatState Vehicle")
		end
	end

    -- Jump squads' unstuck code call. Put ANYWHERE in the DoAbilities() function
    -- Checks jump-able stuck squads, and force them to jump nearby
	if self.isFlyingVersion then
		if self.squad_ai:CanJump() then
			self:SolveStuckCase()
		end
	end
end


function CaestusTactic:DoEntrenchAbility()

	-- Unload troops immediately, since it is not implemented yet
	if not self.isFlyingVersion and self.squad_ai:CanUnload() then
		self.squad_ai:DoUnload()
	end

	local health = self.squad_ai:GetHealthPercentage()

	-- The following is disabled, as the Caestus does NOT self-repair automatically, when landed.
	--[[ Check if we have to land to self-repair, because of low health
	if self.isFlyingVersion and ((health < 0.5 and not self.squad_ai:IsInCombat()) or health < 0.25) then
		if self.squad_ai:CanDoAbility(IFCaestus.land) and not (cpu_manager.terrain_analyzer:HasThreat(self.squad_ai:GetPosition(), 35) or self.squad_ai:WasRecentlyHurt()) then
			self.squad_ai:DoSpecialAbility(IFCaestus.land)
			self.m_iLastEntrenchTime = g_iGMT
			self.entrenchAttempt = g_iGMT
		end
	end]]

	-- Check if we must take off to carry on fighting
	if not self.isFlyingVersion and self.squad_ai:CanDoAbility(IFCaestus.takeoff) then
		if self.squad_ai:WasRecentlyHurt() or  health > 0.85 or (health > 0.6 and BuildBaseStrategy:HasRelic())
		or cpu_manager.terrain_analyzer:HasThreat(self.squad_ai:GetPosition(), 35) then
			self.squad_ai:DoSpecialAbility(IFCaestus.takeoff)
		end
	end
end


function CaestusTactic:Update()

	-- State machine
	if (not VehicleTactic.Update( self )) then
		return false
	end

	if (self:IsComplete()) then
		return
	end

	-- Check if vehicle can be repaired
	if (self.squad_ai:CanBeRepaired() and self.squad_ai:GetNumTroopers() == 1 and not self.squad_ai:IsReinforcing()) then
	
		-- Set repair states
		if (self.squad_ai:IsRanged() and self.squad_ai:GetHealthPercentage() < 0.2) then
			self.m_bNeedRepair = true
		elseif (not self.squad_ai:IsRanged() and not self.squad_ai:WasRecentlyHurt() and self.squad_ai:GetHealthPercentage() < 0.4) then
			self.m_bNeedRepair = true
		end
	end
	
	-- Check if vehicle needs repair
	if (self.m_bNeedRepair) then
			
		-- Check if vehicle is repaired
		aitrace("Current repair target = "..tostring(self.target.x)..", "..tostring(self.target.z))
		if (self.squad_ai:GetHealthPercentage() > 0.99) then
	        self.m_bNeedRepair = false
	        self.hurt_level = 0.6
	    end
	end
	
	self:Upgrade()
	
	self:SyncSubState()
	
	-- Check if ranged vehicle under attack wants to retreat a short distance
	self:Retreat()
	
	if (self.stateID == Tactic.StateID.NoState) then
	
		-- Check dance mode
		if (CpuManager.AISettings.iDancing == 2) then
			self:CheckForDance()
			if (self.stateID == Tactic.StateID.NoState) then
				self:CheckForStealthTroops()
			end
		elseif (CpuManager.AISettings.iDancing == 1 and g_iGMT > self.m_iDancing + 10) then
			self:CheckForDance()
			if (self.stateID == Tactic.StateID.NoState) then
				self:CheckForStealthTroops()
			end
		end
	end
	
	-- Special moves
	self:CloseOnEnemy()
	
	-- Do abilities
	self:InitAbilities()
	self:DoAbilities()
	
	-- Don't update stance if in special substate !
	if (self.stateID == Tactic.StateID.NoState) then
		self:UpdateStance()
	end
	
	return true
end


function CaestusTactic:BeginRetreatState()

	-- Check if we're busy
	if self:IsInSubState() then
		return
	end

	-- Check move delay
	if (g_iGMT < self.m_iMoveDelay + 5 and (self:IsMoving() or self.m_bNeedRepair)) then
		Tactic.SetSubState( self, VehicleTactic.HoldState, "Holding" )
		return
	end

	local vSquadPos = self.squad_ai:GetPosition()
	local iDistance = distance_sqr(self.target, vSquadPos)

	-- Check distance
	if (iDistance > sqr(50) or not self:IsDefender()) then
	
		-- If we are too far away from the retreat position, then make a basic move
		cpu_manager:DoMove(self.squad_ai, self.target, false, "RetreatState Vehicle")
		
	elseif (iDistance > sqr(25) or self.squad_ai:WasRecentlyHurt()) then
	
		-- If we are in range of the retreat position, then make an attack move
		cpu_manager:DoMove(self.squad_ai, self.target, true, "RetreatState Vehicle")
	else
		self.squad_ai:DoStop()
	end
	self.m_iMoveDelay = g_iGMT

	-- Set holding sub-state
	Tactic.SetSubState( self, VehicleTactic.HoldState, "Holding" )
end


------------------------------------------------------------------
-- Unstuck Code --------------------------------------------------
function CaestusTactic:SolveStuckCase()
	local iPosition = self.squad_ai:GetPosition()
	if iPosition.x ~= self.initialPosition.x or iPosition.z ~= self.initialPosition.z then
	-- NOT stuck, update previous position and return, we are all good
		self.initialPosition = iPosition
		return
	end

	-- If we got here, the squad is NOT moving. See if it is simply waiting, or is stuck!
	local state = self.squad_ai:GetTactic():GetState()
	if (self.squad_ai:IsInStateMove() or self.squad_ai:IsInStateAttackMove() or state == "Attack") and not self.squad_ai:IsInCombat()
	and iPosition.x == self.initialPosition.x and iPosition.z == self.initialPosition.z then
	-- STUCK!!!!! Run the unstuck code
		self:ForceSquadJumpNear(iPosition)
	end
	-- Update previous position anyway
	self.initialPosition = self.squad_ai:GetPosition()
end


function CaestusTactic:ForceSquadJumpNear(pos)
	local iPos = self.squad_ai:GetPosition()
	local vJumpPosition = self.squad_ai:GetPosition()
	local jumpDist = self.squad_ai:GetJumpDistance()
	local jumpDistSqr = jumpDist * jumpDist
	local vDir = cpu_manager:GetDirectionToEnemy(pos)
	-- First, try an unstuck jump TOWARDS the enemy 
	-- Try to jump somewhere near, perform 30 checks in total, for a viable position
	for i = 1, 12 do
		-- Create a jump position
		vJumpPosition.x = pos.x + vDir.x * math.random(10, jumpDist)
		vJumpPosition.z = pos.z + vDir.z * math.random(10, jumpDist)
		-- Check if target position is in range and if unit is able to jump to target position
		local iDistanceSqr = distance_sqr(vJumpPosition, iPos)
		if iDistanceSqr < jumpDistSqr and self.squad_ai:CanJumpToPosition(vJumpPosition) then
			-- Jump to position
			self.squad_ai:DoJump(vJumpPosition)
			self.last_jump = g_iGMT
			self.m_iLastGatherMove = self.last_jump - 10
			return
		end
	end
	-- Then try any random nearby place, as a secondary option
	for i = 1, 18 do
		-- Create a jump position
		vJumpPosition.x = pos.x + 0.7 * math.random(-jumpDist, jumpDist)
		vJumpPosition.z = pos.z + 0.7 * math.random(-jumpDist, jumpDist)
		-- Check if target position is in range and if unit is able to jump to target position
		local iDistanceSqr = distance_sqr(vJumpPosition, iPos)
		if iDistanceSqr < jumpDistSqr and self.squad_ai:CanJumpToPosition(vJumpPosition) then
			-- Jump to position
			self.squad_ai:DoJump(vJumpPosition)
			self.last_jump = g_iGMT
			self.m_iLastGatherMove = self.last_jump - 10
			return
		end
	end
end
