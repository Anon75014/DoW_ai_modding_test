----------------------------------------
-- File: 'stormraventactic.ai'
-- Edited by Gambit @ 14.06.2021
-- Edited by Thudmeizer @ 04.02.2024

class 'StormRavenTactic' (DaemonhuntVehicleGKTactic)

GKStormRaven = {}

function StormRavenTactic:__init( squad_ai ) super( squad_ai )

	self:SetName("Storm Raven tactic")

	-- Assume stormraven has just entrenched/retrenched
	self.m_iLastEntrenchTime = g_iGMT
	self.entrenchAttempt = g_iGMT

	-- Get the type we have
	self.isFlyingVersion = self.squad_ai:GetSquadName() == "inquisition_squad_stormraven_fury"

	-- Get ID and loaded status for the NEW flying SR, and if it was previously loaded
	if self.isFlyingVersion then
		if SR_FlyingID == nil or self.squad_ai:GetID() ~= SR_FlyingID then
			SR_IsLoaded = false
			SR_FlyingID = self.squad_ai:GetID()
		end
	end

	-- Used for the stuck check code for the squads that can jump
	self.initialPosition = self.squad_ai:GetPosition()
end

function StormRavenTactic:InitAbilities()

	-- Init ability ID's
	if (GKStormRaven.land == nil or GKStormRaven.takeoff == nil) then
		GKStormRaven.land = cpu_manager.stats:GetAbilityID("inquisition_stormraven_land")
		GKStormRaven.takeoff = cpu_manager.stats:GetAbilityID("inquisition_stormraven_takeoff")
	end
end

--[[
function StormRavenTactic:NeedRepair()
	return false
end
]]

function StormRavenTactic:DoAbilities()

	-- Try to entrench first
	self:DoEntrenchAbility()

	-- If TOO damaged, retreat
	if g_iGMT > self.entrenchAttempt + 3 then
		if self.isFlyingVersion and self.squad_ai:GetHealthPercentage() < 0.3 then
			self:SetState(Tactic.States.Retreat)
			Tactic.SetState(self, self:GetState())
			self:BeginRetreatState()
			cpu_manager:DoMove(self.squad_ai, cpu_manager.start_pos, false, "RetreatState Vehicle")
		end
	end

	-- New code to unstuck units with pathing issues, that can jump.
	-- Call it with [true], only for multi-membered squads.
	self:SolveStuckCase(false)
end

function StormRavenTactic:DoEntrenchAbility()

	-- Unload troops immediately, since it is not implemented yet
	if not self.isFlyingVersion and self.squad_ai:CanUnload() then
		self.squad_ai:DoUnload()
	end

--[[
	--  Don't land/takeoff too fast after last attempt. Disabled, not needed.
	if (g_iGMT < self.m_iLastEntrenchTime + 30) then
		return
	end
]]

	local health = self.squad_ai:GetHealthPercentage()

-- Disabled as flier does not land at start_pos due to being held by standard vehicle repair code after retreat. Flier gets repaired regardless at start_pos due to being normal vehicle
--[[
	-- Check if we have to land back at start_pos to be repaired, because of low health
	if self.isFlyingVersion and ((health < 0.5 and not self.squad_ai:IsInCombat()) or health < 0.25) then
		if self.squad_ai:CanDoAbility(GKStormRaven.land) and not (cpu_manager.terrain_analyzer:HasThreat(self.squad_ai:GetPosition(), 35) or self.squad_ai:WasRecentlyHurt()) then
			self:SetState(Tactic.States.Retreat)
			Tactic.SetState(self, self:GetState())
			self:BeginRetreatState()
			cpu_manager:DoMove(self.squad_ai, cpu_manager.start_pos, false, "RetreatState Vehicle")

			-- Check for damaged flying vehicle close to start point then attempt to land to get repaired
			local vSquadPos = self.squad_ai:GetPosition()
			local iDistance = distance_sqr(self.target, vSquadPos)
			if (self.m_bNeedRepair and iDistance < sqr(50) and self.squad_ai:WasRecentlyHurt() and distance_sqr(self.target, cpu_manager.start_pos) < 1) then
				self.squad_ai:DoSpecialAbility(GKStormRaven.land)
				self.m_iLastEntrenchTime = g_iGMT
				self.entrenchAttempt = g_iGMT
			end
		end
	end

	-- Check for damaged flying vehicle close to start point then attempt to land to get repaired
	local vSquadPos = self.squad_ai:GetPosition()
	local iDistance = distance_sqr(self.target, vSquadPos)
	if self.isFlyingVersion and ((health < 0.5 and not self.squad_ai:IsInCombat()) or health < 0.25) then
		if self.squad_ai:CanDoAbility(GKStormRaven.land) and not (cpu_manager.terrain_analyzer:HasThreat(self.squad_ai:GetPosition(), 35) or self.squad_ai:WasRecentlyHurt()) then
			--if (self.m_bNeedRepair and iDistance < sqr(50) and self.squad_ai:WasRecentlyHurt() and distance_sqr(self.target, cpu_manager.start_pos) < 1) then
			if (iDistance < 200) then
				self.squad_ai:DoSpecialAbility(GKStormRaven.land)
				self.m_iLastEntrenchTime = g_iGMT
				self.entrenchAttempt = g_iGMT
			end
		end
	end
]]
	-- Check if we must take off to carry on fighting
	if not self.isFlyingVersion and self.squad_ai:CanDoAbility(GKStormRaven.takeoff) then
		if self.squad_ai:WasRecentlyHurt() or health > 0.85 or (health > 0.6 and BuildBaseStrategy:HasRelic())
		or cpu_manager.terrain_analyzer:HasThreat(self.squad_ai:GetPosition(), 35) then
			self.squad_ai:DoSpecialAbility(GKStormRaven.takeoff)
		end
	end
end

function StormRavenTactic:Update()

	-- State machine
	if (not VehicleTactic.Update( self )) then
		return false
	end
--[[
	if (self:IsComplete()) then
		return
	end

	-- Check if vehicle can be repaired
	if (self.squad_ai:CanBeRepaired() and self.squad_ai:GetNumTroopers() == 1 and not self.squad_ai:IsReinforcing()) then
	
		-- Set repair states
		if (self.squad_ai:IsRanged() and self.squad_ai:GetHealthPercentage() < 0.2) then
			self.m_bNeedRepair = true
		elseif (not self.squad_ai:IsRanged() and not self.squad_ai:WasRecentlyHurt() and self.squad_ai:GetHealthPercentage() < 0.4) then
			self.m_bNeedRepair = true
		end
	end
	
	-- Check if vehicle needs repair
	if (self.m_bNeedRepair) then
			
		-- Check if vehicle is repaired
		aitrace("Current repair target = "..tostring(self.target.x)..", "..tostring(self.target.z))
		if (self.squad_ai:GetHealthPercentage() > 0.99) then
	        self.m_bNeedRepair = false
	        self.hurt_level = 0.6
	    end
	end
	
	if (self.squad_ai:CanJump()) then
		self.tolerance_default = self.squad_ai:GetJumpDistance()
	else
		self.tolerance_default = 100
	end
	
	self:Upgrade()
	
	self:Reinforce()
]]
	self:SyncSubState()
	
	-- Check if ranged vehicle under attack wants to retreat a short distance
	self:Retreat()
	
	if (self.stateID == Tactic.StateID.NoState) then
	
		-- Check dance mode
		if (CpuManager.AISettings.iDancing == 2) then
			self:CheckForDance()
			if (self.stateID == Tactic.StateID.NoState) then
				self:CheckForStealthTroops()
			end
		elseif (CpuManager.AISettings.iDancing == 1 and g_iGMT > self.m_iDancing + 10) then
			self:CheckForDance()
			if (self.stateID == Tactic.StateID.NoState) then
				self:CheckForStealthTroops()
			end
		end
	end
	
	-- Special moves
	self:CloseOnEnemy()
	
	-- Do abilities
	self:InitAbilities()
	self:DoAbilities()
	
	-- Don't update stance if in special substate !
	if (self.stateID == Tactic.StateID.NoState) then
		self:UpdateStance()
	end
	
	return true
end

function StormRavenTactic:BeginRetreatState()

	-- Check if we're busy
	if self:IsInSubState() then
		return
	end

	-- Check move delay
	if (g_iGMT < self.m_iMoveDelay + 5 and (self:IsMoving() or self.m_bNeedRepair)) then
		Tactic.SetSubState( self, VehicleTactic.HoldState, "Holding" )
		return
	end

	local vSquadPos = self.squad_ai:GetPosition()
	local iDistance = distance_sqr(self.target, vSquadPos)

--[[ 
	-- Try to unload troops
	if (self:UnloadTroops(iDistance)) then
		self.m_iMoveDelay = g_iGMT - 3
		Tactic.SetSubState(self, self.HoldState, "Holding")
		return
	end
	
	-- Check for damaged vehicles close to start point
	if (self.m_bNeedRepair and iDistance < sqr(50) and not self.squad_ai:WasRecentlyHurt() and
		distance_sqr(self.target, cpu_manager.start_pos) < 1) then
		
		if ((self.squad_ai:IsInStateAttackMove() or self.squad_ai:IsInStateMove()) and not self:IsMoving()) then
			self.squad_ai:DoStop()
			self.m_iMoveDelay = g_iGMT + 15	
		end
		Tactic.SetSubState( self, VehicleTactic.HoldState, "Holding" )
		return
	end
]]
	-- Check distance
	if (iDistance > sqr(50) or not self:IsDefender()) then
	
		-- If we are too far away from the retreat position, then make a basic move
		cpu_manager:DoMove(self.squad_ai, self.target, false, "RetreatState Vehicle")
		
	elseif (iDistance > sqr(25) or self.squad_ai:WasRecentlyHurt()) then
	
		-- If we are in range of the retreat position, then make an attack move
		cpu_manager:DoMove(self.squad_ai, self.target, true, "RetreatState Vehicle")
	else
		self.squad_ai:DoStop()
	end
	self.m_iMoveDelay = g_iGMT

	-- Set holding sub-state
	Tactic.SetSubState( self, VehicleTactic.HoldState, "Holding" )
end
