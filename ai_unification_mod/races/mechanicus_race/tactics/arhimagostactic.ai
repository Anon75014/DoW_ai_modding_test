----------------------------------------
-- File: 'ArhimagosTactic.ai'
-- Edited by Arkhan 	@ 10.01.2007
-- Edited by I_Chample@ 23.06.2014
-- Edited by Gambit @ 30.10.2015

class 'ArhimagosTactic' (MechInfantryTactic)

Arhimagos = {}

function ArhimagosTactic:__init( squad_ai ) super( squad_ai )

	self:SetName("Arhimagos Tactic")

	self.spawnTime = g_iGMT
	self.isArchMagosPrime = false
	self.initialPosition = self.squad_ai:GetPosition()
	self.isStuck = false

	-- Engineer Tactic Settings, modify as required
	self.iBusy = g_iGMT
	self.iSquadName = self.squad_ai:GetSquadName()   --> The name of the SQUAD with the dual role
	self.iRepairVehicleRange = 40   --> The range within which the squad will perform the vehicle repairs
	self.iRepairSuperVehiclesWhenInCombat = true  --> Will repair super vehicles, even if in combat
	self.isBuildingsRepairer  = true  --> Will also repair nearby structures if true
	if self.iSquadName == "mechanicus_squad_arhimagos_prime" then
		self.iRepairStrongVehiclesWhenInCombat = false  --> Will also repair super vehicles if true
		self.isBuildingsAssistant  = false  --> Will also help build nearby unfinished structures if true
		self.isArchMagosPrime = true --> Used for the initial jump
	else
		self.iRepairStrongVehiclesWhenInCombat = true  --> Will also repair super vehicles if true
		self.isBuildingsAssistant  = true  --> Will also help build nearby unfinished structures if true
	end
	self.iFixBuildingsRange = 30  --> The range within which the squad will perform building duties
end


function ArhimagosTactic:IsAttacker()
	return true
end


function ArhimagosTactic:IsDefender()
	return true
end


function ArhimagosTactic:IsSupportDetector()
	return true
end


function ArhimagosTactic:InitAbilities()
	if (Arhimagos.battlecry == nil) then
		Arhimagos.battlecry = cpu_manager.stats:GetAbilityID( "mechanicus_battlecry" )
	end
	if (Arhimagos.thunderbolt_strike == nil) then
		Arhimagos.thunderbolt_strike = cpu_manager.stats:GetAbilityID( "mechanicus_thunderbolt_strike" )
	end
	if (Arhimagos.blessing_id == nil) then
		Arhimagos.blessing_id = cpu_manager.stats:GetAbilityID( "mechanicus_blessing_of_the_omnissiah" )
	end
end


function ArhimagosTactic:DoAbilities()

	-- Use the vehicle health-restoring ability
	if (self.squad_ai:CanDoAbility(Arhimagos.blessing_id)) then
		local range = self.squad_ai:GetAbilityRange( Arhimagos.blessing_id )	
		local squad_filter = function( squad_ai )		
			return squad_ai:CanBeRepaired() and squad_ai:IsInCombat() and squad_ai:GetHealthPercentage() < 0.6
		end	
   		local oSquad = cpu_manager:GetClosestSquad( self.squad_ai:GetPosition(), range, squad_filter )
		if (oSquad ~= nil) then
			oStats = oSquad:GetStats()
			if (oStats ~= nil) then
				local eClass = oStats:GetClass()
				local eName = oSquad:GetSquadName()
				if (eClass == UnitStatsAI.UC_VehicleLow or eClass == UnitStatsAI.UC_VehicleMed or eClass == UnitStatsAI.UC_VehicleHigh
				or eClass == UnitStatsAI.UC_AirMed or eName == "mechanicus_squad_knight") then
					self.squad_ai:DoSpecialAbilitySquad( Arhimagos.blessing_id, oSquad:GetSquad() )
				end
			end
 		end
	end

	-- Use the morale-restoring ability to bring nearby vehicles back on-line
	if self.squad_ai:CanDoAbility(Arhimagos.battlecry) then
		local oUnit = Ability.Filters.CloseBroken(self.squad_ai:GetPosition(), 25, 1)
		if oUnit ~= nil then
			self.squad_ai:DoSpecialAbility(Arhimagos.battlecry)
		end
	end

	-- Use the Thunderbolt bombing ability
	Ability.DoAbilityPos( self.squad_ai, Arhimagos.thunderbolt_strike, Ability.Filters.CloseEnemy, 6 )

    -- Jump squads' unstuck code call. Put ANYWHERE in the DoAbilities() function
    -- Checks jump-able stuck squads, and force them to jump nearby
	if self.isArchMagosPrime and self.squad_ai:CanJump() then
		self:SolveStuckCase()
	end

	--[[ OBSOLETE unstuck method
	-- The Archmagos Prime sometimes is blocked on spawn (bigger size). We use the code below to try to avoid such instances.
	-- Jump squads' initial unstuck attempt code - put AT THE END of DoAbilities() function
	if self.initialPosition == nil then return end -- no need for it, once fulfilled its task
	local iDistance = distance_sqr(self.squad_ai:GetPosition(), self.initialPosition)
	if g_iGMT > self.spawnTime + 28 or iDistance > 512 or self.squad_ai:IsInCombat() then
		-- We are most possibly non-stuck
		self.initialPosition = nil
	elseif g_iGMT > self.spawnTime + 9 then
		-- Try to jump somewhere near
		for iLoop1 = 1, 8 do
			-- Create a jump position
			local vJumpPosition = self.initialPosition
			local vDir = cpu_manager:GetDirectionToEnemy(self.squad_ai:GetPosition())
			vJumpPosition.x = vJumpPosition.x + vDir.x * math.random(15, 32)
			vJumpPosition.z = vJumpPosition.z + vDir.z * math.random(15, 32)
			-- Check if target position is in range and if unit is able to jump to target position
			local iDistance = distance_sqr(vJumpPosition, self.initialPosition)
			if (iDistance <= sqr(self.squad_ai:GetJumpDistance()) and self.squad_ai:CanJumpToPosition(vJumpPosition)) then				
				-- Jump to position
				self.squad_ai:DoJump(vJumpPosition)
				self.last_jump = g_iGMT
				self.m_iLastGatherMove = self.last_jump - 10
				return
			end
		end
	end]]
end


-----------------------------------------
-- Update tactic for dual-duty squads  --
-----------------------------------------

function ArhimagosTactic:Update()

	-- State machine
	if not Tactic.Update( self ) then
		return false
	end

	-- Reinforce squads
	self:Reinforce()

	-- Upgrade weapons
	self:Upgrade()

	-- Do abilities even if this means interrupting engineer duties.
	-- Place the following two lines AFTER the locked check below,
	--  if you do not want abilities to interrupt them.
	-- Alternative, make specific IF checks, in case you want each
	--  ability to have different behaviour.
	self:InitAbilities()
	self:DoAbilities()

	-- Check if locked, and not attacked while being so, so that to fulfil his tasks
	if (self.squad_ai:IsLocked() and not self.squad_ai:WasRecentlyHurt()) then
		return true
   	end

	if self.squad_ai:CanJump() then
		self.tolerance_default = self.squad_ai:GetJumpDistance()
	else
		self.tolerance_default = 100
	end

	-- Update commander attach/detach health
	local iSupportCap = build_manager:GetSupportCapCurrentMax() - build_manager:GetSupportCapLeft()
	if (iSupportCap >= 4) then
		self.m_fCommanderAttachHealth = 0.3
	else
		self.m_fCommanderAttachHealth = 0.1
	end

	self:SyncSubState()

	self:CheckForBroken()

	-- If not already in substate
	if (self.stateID == Tactic.StateID.NoState) then
	   
		-- Check dance mode
		if (CpuManager.AISettings.iDancing == 2) then
		 	self:CheckForDeath()
			if (self.stateID == Tactic.StateID.NoState) then
				self:CheckForDance()
				if (self.stateID == Tactic.StateID.NoState) then
					self:CheckForStealthTroops()
				end
			end
		elseif (CpuManager.AISettings.iDancing == 1 and g_iGMT > self.m_iDancing + 10) then
			self:CheckForDeath()
			if (self.stateID == Tactic.StateID.NoState) then
				self:CheckForDance()
				if (self.stateID == Tactic.StateID.NoState) then
					self:CheckForStealthTroops()
				end
			end
		end
	end

	if (cpu_manager.assassinate and self.stateID == Tactic.StateID.NoState) then
	
		for i in self.commander do
		
			if self.squad_ai:HasSquadAttached( self.commander[i][1] ) and self.commander[i][2] then
				
				--if I'm nearly dead, run away
				if self.squad_ai:GetAttachedHealthPercentage() < 0.7 then
				   self.squad_ai:DoMoveToClosestSafePoint( self.safe_point, self.tolerance )
				end
				return
			end
		end
	end

	if (self.squad_ai:IsAttached()) then
		self:CheckForDetach()
	end

	-- Special moves after a while
	if g_iGMT > self.iBusy + 6 then
		self:CloseOnEnemy()
	end

	-- Check stance
	self:UpdateStance()

	-- Perform engineer duties
	self:DoEngineerDuties()

	-- If no tasks after a while, or attacked while building a structure, engage closest enemy.
	if ((not (self:IsMoving() or self.squad_ai:IsInCombat()) and g_iGMT > self.iBusy + 6) or
	(self.squad_ai:IsBuilding() ~= 0 and self.squad_ai:WasRecentlyHurt())) and (not cpu_manager.assassinate) then
		self:EngageClosestEnemyIfNeeded()
	end

	-- Assassinate win condition -- never attach to a squad
    if (not cpu_manager.assassinate and self.squad_ai:GetMeleeStance() == SquadAI.MSTANCE_Assault) then
         
        if (self.squad_ai:IsInCombat() or self.squad_ai:WasRecentlyHurt()) then
        
            if (self:TryAttachSquad(false, true, 30, 150, self.m_fCommanderAttachHealth) == nil) then
                self:TryAttachSquadMelee()
            end
        end
    end

	-- Return success
	return true
end


------------------------------------------------
-- Code for dual-duty squads (also engineers) --
------------------------------------------------

-- Moves the squad to engage the enemy. Usually called if idle, or attacked during building a structure
function ArhimagosTactic:EngageClosestEnemyIfNeeded()
	-- Define squad filter functor
	local oSquadFilter = function( oSquadAI )
		return oSquadAI:IsInCombat()
	end
	-- Get closest enemy squad to engage
    local oEnemySquad = cpu_manager:FindClosestEnemy(self.squad_ai:GetPosition(), 1512, oSquadFilter)
    if (oEnemySquad ~= nil) then
		local targetPosition = oEnemySquad:GetPosition()
		if Ability.Filters.CloseHurt(targetPosition, 40, 1) ~= nil then
			self.squad_ai:DoMove(targetPosition)
		end
	end
end


-- Performs the repair and building tasks
function ArhimagosTactic:DoEngineerDuties()
	-- Assisting boolean, so that not to call GetDmgdOrUnfnsdBuildingWithin twice
	local iCheck = true

	-- Try to repair a nearby damaged vehicle. If no vehicle, find a damaged building
	if self.squad_ai:CanRepair() then
		-- First, find the closest vehicle that can be repaired
		local oVehicleToRepair = self:GetDamagedVehicleWithin(self.iRepairVehicleRange)
		if (oVehicleToRepair ~= nil) then
			-- Prefer to repair a powerful vehicle, even in battle
			local superVehicle = false
			local strongVehicle = false
			if self.iRepairSuperVehiclesWhenInCombat then
				local vStats = oVehicleToRepair:GetStats()
				if  vStats ~= nil then
					local vClass = vStats:GetClass()
					if vClass ~= nil then
						if vClass == UnitStatsAI.UC_VehicleHigh then
							superVehicle = true
						end
					end
				end
			elseif self.iRepairStrongVehiclesWhenInCombat then
				local vStats = oVehicleToRepair:GetStats()
				if  vStats ~= nil then
					local vClass = vStats:GetClass()
					if vClass ~= nil then
						if vClass == UnitStatsAI.UC_VehicleMed then
							strongVehicle = true
						end
					end
				end
			end
			if not self.squad_ai:IsInCombat() or superVehicle or strongVehicle then
				aitrace("EngineerTactic: Repairing vehicle...")
				self.squad_ai:DoRepairSquad(oVehicleToRepair)
				self.iBusy = g_iGMT
				return true
			end
		end
		-- Then, find the closest building that can be repaired
		if self.isBuildingsRepairer then
			self:GetDmgdOrUnfnsdBuildingWithin(self.iFixBuildingsRange)
			iCheck = false
			if not self.squad_ai:IsInCombat() then
				local oBuildingToRepair = self:GetDamagedBuilding()
				if (oBuildingToRepair ~= nil) then
					aitrace("EngineerTactic: Repairing building...")
					self.squad_ai:DoRepairBase(oBuildingToRepair)
					self.iBusy = g_iGMT
					return true
				end
			end
		end
	end
	-- Then, try to help finish a building
	if self.isBuildingsAssistant then
		if self.squad_ai:IsEngineer() and not self.squad_ai:IsInCombat() then
			if iCheck then
				self:GetDmgdOrUnfnsdBuildingWithin(self.iFixBuildingsRange)
			end
			local oBuildingToFinish = self:GetUnfinishedBuilding()
			if (oBuildingToFinish ~= nil) then
				aitrace("EngineerTactic: Help finishing a building...")
				self.squad_ai:DoFinishBuilding(oBuildingToFinish)
				self.iBusy = g_iGMT
				return true
			end
		end
	end
end


-- Called directly to find an ally repairable and damaged squad within range.
function ArhimagosTactic:GetDamagedVehicleWithin(iRange)
local iEngineerSquadPosition = self.squad_ai:GetPosition()
for oPlayer in cpu_manager.stats:GetPlayerStats() do
	if not oPlayer:IsPlayerDead() then
		if not cpu_manager.player_stats:IsEnemy(oPlayer) then
			for oSquad in oPlayer:GetSquads() do
				if oSquad:IsValid() then
					if oSquad:CanBeRepaired() and oSquad:GetHealthPercentage() < 1.0
					and oSquad:GetSquadName() ~= self.iSquadName then
						if distance_sqr(oSquad:GetPosition(),iEngineerSquadPosition) < iRange*iRange then 
							return oSquad
						end
					end
				end
			end
		end
	end
end
return nil
end


-- Called indirectly, to find an ally repairable and damaged building, or an unfinished within range.
function ArhimagosTactic:GetDmgdOrUnfnsdBuildingWithin(iRange)
self.damagedBuilding = nil
self.unfinishedBuilding = nil
local iEngineerSquadPosition = self.squad_ai:GetPosition()
for oPlayer in cpu_manager.stats:GetPlayerStats() do
	if (not oPlayer:IsPlayerDead()) then
		if (not cpu_manager.player_stats:IsEnemy(oPlayer)) then
			for oBuilding in oPlayer:GetBases() do
				if oBuilding:IsValid() then
					if distance_sqr(oBuilding:GetPosition(),iEngineerSquadPosition) < iRange*iRange then
						if (self.isBuildingsRepairer and oBuilding:CanBeRepaired() and oBuilding:GetHealthPercentage() < 1.0) then
							self.damagedBuilding = oBuilding
							return
						elseif (self.isBuildingsAssistant and not oBuilding:IsConstructionDone()) then
							self.unfinishedBuilding = oBuilding:GetEntity()
							return
						end
					end
				end
			end
		end
	end
end
end


function ArhimagosTactic:GetDamagedBuilding()
	return self.damagedBuilding
end


function ArhimagosTactic:GetUnfinishedBuilding()
	return self.unfinishedBuilding
end

------------------------------------------------------------------------------------------
-- Unstuck Functions
function ArhimagosTactic:SolveStuckCase()
	local iPosition = self.squad_ai:GetPosition()
	if iPosition.x ~= self.initialPosition.x or iPosition.z ~= self.initialPosition.z then
		self.isStuck = false
	elseif (self.squad_ai:IsInStateMove() or self.squad_ai:IsInStateAttackMove()) and not self.squad_ai:IsInCombat()
	and iPosition.x == self.initialPosition.x and iPosition.z == self.initialPosition.z then
		self.isStuck = true
	end
	if self.isStuck then
		self:ForceSquadJumpNear(iPosition)
	end
	self.initialPosition = self.squad_ai:GetPosition()
end

function ArhimagosTactic:ForceSquadJumpNear(pos)
	-- Try to jump somewhere near, perform 16 checks for a viable position
	local jumpDisSqr = sqr(self.squad_ai:GetJumpDistance())
	for iLoop1 = 1, 16 do
		-- Create a jump position
		local vJumpPosition = pos
		local vDir = cpu_manager:GetDirectionToEnemy(pos)
		vJumpPosition.x = vJumpPosition.x + vDir.x * math.random(-20, 50)
		vJumpPosition.z = vJumpPosition.z + vDir.z * math.random(-20, 50)
		-- Check if target position is in range and if unit is able to jump to target position
		local iDistance = distance_sqr(vJumpPosition, pos)
		if iDistance < jumpDisSqr and self.squad_ai:CanJumpToPosition(vJumpPosition) then
			-- Jump to position
			self.squad_ai:DoJump(vJumpPosition)
			self.last_jump = g_iGMT
			self.m_iLastGatherMove = self.last_jump - 10
			return
		end
	end
end