----------------------------------------
-- File: 'SkullProbesTactic.ai'
-- Edited by Gambit   @ 12.11.2016

class 'SkullProbesTactic' (MechInfantryTactic)

function SkullProbesTactic:__init( squad_ai ) super( squad_ai )

	self:SetName("SkullProbes Tactic")

	-- Engineer Tactic Settings, modify as required
	self.isRepairing = false
	self.iBusy = g_iGMT
	self.iSquadName = self.squad_ai:GetSquadName()   --> The name of the SQUAD with the dual role, so that not to repair itself!
	self.iRepairVehicleRange = 50   --> The range within which the squad will perform the vehicle repairs
	self.isBuildingsRepairer  = true  --> Will repair nearby structures if true
	self.iFixBuildingsRange = 30  --> The range within which the squad will perform building duties
end


function SkullProbesTactic:IsSupportDetector()
	return true
end


-- Should only attack when attached
function SkullProbesTactic:IsAttacker()
	return false
end


-- Should only defend when attached
function SkullProbesTactic:IsDefender()
	return false
end


function SkullProbesTactic:DoAbilities()
	-- Go and protect broken squads if not attached
	if not self.squad_ai:IsAttached() then
		if not self.isRepairing and g_iGMT > self.iBusy + 12 then
			local oUnit = Ability.Filters.CloseBroken(self.squad_ai:GetPosition(), 256, 1)
			if oUnit ~= nil then
				self.iBusy = g_iGMT
				self.stateID = Tactic.StateID.Attack
				cpu_manager:DoMove(self.squad_ai, oUnit:GetPosition(), false, "Provide Link!" )
				--print("Move to Provide Link")
			end
		end
	end
end


-----------------------------------------
-- Update tactic for dual-duty squads  --
-----------------------------------------

function SkullProbesTactic:Update()
--print(self.isRepairing)

	-- State machine
	if not Tactic.Update( self ) then
		return false
	end

	-- Reinforce squads
	--self:Reinforce()

	-- Upgrade weapons
	--self:Upgrade()

	-- Do abilities even if this means interrupting engineer duties.
	-- Place the following two lines AFTER the locked check below,
	--  if you do not want abilities to interrupt them.
	-- Alternative, make specific IF checks, in case you want each
	--  ability to have different behaviour.
	self:InitAbilities()
	self:DoAbilities()

	-- Check if locked, and not attacked while being so, so that to fulfil his tasks
	if self.squad_ai:IsLocked() then
		return true
   	end

	if self.squad_ai:CanJump() then
		self.tolerance_default = self.squad_ai:GetJumpDistance()
	else
		self.tolerance_default = 100
	end

	-- Update commander attach/detach health
	local iSupportCap = build_manager:GetSupportCapCurrentMax() - build_manager:GetSupportCapLeft()
	if (iSupportCap >= 4) then
		self.m_fCommanderAttachHealth = 0.3
	else
		self.m_fCommanderAttachHealth = 0.1
	end

	self:SyncSubState()

	--self:CheckForBroken()

	-- If not already in substate. But do NOT interrupt repairs
	if self.isRepairing then
		self.stateID = Tactic.StateID.Iddle
	elseif self.stateID == Tactic.StateID.NoState then
	   
		-- Check dance mode
		if (CpuManager.AISettings.iDancing == 2) then
		 	self:CheckForDeath()
			if (self.stateID == Tactic.StateID.NoState) then
				self:CheckForDance()
				if (self.stateID == Tactic.StateID.NoState) then
					self:CheckForStealthTroops()
				end
			end
		elseif (CpuManager.AISettings.iDancing == 1 and g_iGMT > self.m_iDancing + 10) then
			self:CheckForDeath()
			if (self.stateID == Tactic.StateID.NoState) then
				self:CheckForDance()
				if (self.stateID == Tactic.StateID.NoState) then
					self:CheckForStealthTroops()
				end
			end
		end
	end

	-- Perform engineer duties
	if not self.squad_ai:IsAttached() then
		self:DoEngineerDuties()
	end

	-- Try to attach to a squad. UPDATED version for Skull Probes
	if not self.isRepairing or math.random( 1,3 ) == 1 then
		if self:SpecialTryAttachSquad(450) then
			return true
		end
	end

	-- If no tasks after a while, engage closest enemy.
	if (not (self:IsMoving() or self.squad_ai:IsInCombat()) and g_iGMT > self.iBusy + 6) and (not self.isRepairing) then
		self:EngageClosestEnemyIfNeeded()
	end

	-- Check stance
	self.squad_ai:DoSetStance( SquadAI.STANCE_StandGround )

	-- Return success
	return true
end


-- Special attach function for skull probes
function SkullProbesTactic:SpecialTryAttachSquad(radius)

	local filter = function( squad_ai )
		return self.squad_ai:CanAttachTo( squad_ai ) and
		(squad_ai:IsBroken() or (squad_ai:GetHealthPercentage() < 0.85 and squad_ai:GetNumTroopers() > 2))
	end

	-- try to attach
	local attach_to = cpu_manager:GetClosestSquad( self.squad_ai:GetPosition(), radius, filter )
	if attach_to ~= nil then
		self.iBusy = g_iGMT
		self:DoMoveAttach( attach_to )		 
		return true
	end

	return false
end



------------------------------------------------
-- Code for dual-duty squads (also engineers) --
------------------------------------------------

-- Moves the squad to engage the enemy. Usually called if idle, or attacked during building a structure
function SkullProbesTactic:EngageClosestEnemyIfNeeded()
	-- Define squad filter functor
	local oSquadFilter = function( oSquadAI )
		return oSquadAI:IsInCombat()
	end
	-- Get closest enemy squad to engage
    local oEnemySquad = cpu_manager:FindClosestEnemy(self.squad_ai:GetPosition(), 1512, oSquadFilter)
    if (oEnemySquad ~= nil) then
		local targetPosition = oEnemySquad:GetPosition()
		if Ability.Filters.CloseHurt(targetPosition, 40, 1) ~= nil or Ability.Filters.CloseBroken(targetPosition, 40, 1) ~= nil then
			self.squad_ai:DoMove(targetPosition)
			self.iBusy = g_iGMT
			self.stateID = Tactic.StateID.Attack
			--print("Move to Engage")
		end
	end
end


-- Performs the repair and building tasks
function SkullProbesTactic:DoEngineerDuties()
	local iTempRange = self.iRepairVehicleRange
	-- If we are already attempting to repair, do not run after a running target if not closing.
	if self.isRepairing then
		iTempRange = self.iRepairVehicleRange/2
		self.isRepairing = false
	end
	-- Try to repair a nearby damaged vehicle. If no vehicle, find a damaged building
	if self.squad_ai:CanRepair() then
		-- First, find the closest vehicle that can be repaired
		local oVehicleToRepair = self:GetDamagedVehicleWithin(iTempRange)
		if (oVehicleToRepair ~= nil) then
			aitrace("EngineerTactic: Repairing vehicle...")
			self.squad_ai:DoRepairSquad(oVehicleToRepair)
			--print("Move to Repair: "..oVehicleToRepair:GetSquadName())
			self.isRepairing  = true
			self.iBusy = g_iGMT
			return true
		end
		-- Then, find the closest building that can be repaired
		local oBuildingToRepair = self:GetDamagedBuildingWithin(self.iFixBuildingsRange)
		if (oBuildingToRepair ~= nil) then
			aitrace("EngineerTactic: Repairing building...")
			self.squad_ai:DoRepairBase(oBuildingToRepair)
			self.iBusy = g_iGMT
			return true
		end
	end
end


function SkullProbesTactic:GetDamagedVehicleWithin(iRange)
local iEngineerSquadPosition = self.squad_ai:GetPosition()
for oPlayer in cpu_manager.stats:GetPlayerStats() do
	if not oPlayer:IsPlayerDead() then
		if not cpu_manager.player_stats:IsEnemy(oPlayer) then
			for oSquad in oPlayer:GetSquads() do
				if oSquad:IsValid() then
					if oSquad:CanBeRepaired() and oSquad:GetHealthPercentage() < 1.0
					and oSquad:GetSquadName() ~= self.iSquadName then
						if distance_sqr(oSquad:GetPosition(),iEngineerSquadPosition) < iRange*iRange then 
							return oSquad
						end
					end
				end
			end
		end
	end
end
return nil
end


function SkullProbesTactic:GetDamagedBuildingWithin(iRange)
local iEngineerSquadPosition = self.squad_ai:GetPosition()
for oPlayer in cpu_manager.stats:GetPlayerStats() do
	if (not oPlayer:IsPlayerDead()) then
		if (not cpu_manager.player_stats:IsEnemy(oPlayer)) then
			for oBuilding in oPlayer:GetBases() do
				if oBuilding:IsValid() then
					if distance_sqr(oBuilding:GetPosition(),iEngineerSquadPosition) < iRange*iRange then
						if (oBuilding:CanBeRepaired() and oBuilding:GetHealthPercentage() < 1.0) then
							return oBuilding
						end
					end
				end
			end
		end
	end
end
return nil
end

------------------------------------------------------------------------------------------
