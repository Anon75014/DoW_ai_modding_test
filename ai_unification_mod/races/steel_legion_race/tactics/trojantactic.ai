----------------------------------------
-- File: 'trojantactic.ai'
-- Edited by Thudmeizer @ 01.02.2025

class 'TrojanTactic' (SteelLegionVehicleTactic)

Trojan = {}
Atlas = {}

function TrojanTactic:__init( squad_ai ) super( squad_ai )

	self:SetName("Trojan and Atlas Tactic")

	self.tagged_flag = nil

	self.go_to_post = false
	
	self.m_vDestination = nil
	
	self.m_iValidRange = sqr(35)
	self.m_bBusy = false

	-- Atlas possible repair targets (one var for both Vehicles and Buildings)
	self.m_iTargetForRepair = nil
end

function TrojanTactic:IsAttacker()
	return false
end

function TrojanTactic:IsDefender()
	return false
end

function TrojanTactic:InitAbilities()

	if (Trojan.smoke_id == nil) then
		Trojan.smoke_id = cpu_manager.stats:GetAbilityID( "steel_legion_smoke_launchers" )
		Atlas.repair_boost_id = cpu_manager.stats:GetAbilityID( "steel_legion_atlas_repair_boost" )
	end
end

function TrojanTactic:DoAbilities()

	-- Check if we can deploy smoke grenades
	if (self.squad_ai:CanDoAbility(Trojan.smoke_id)) then
	
		-- Search a squad
		local iRange = self.squad_ai:GetAbilityRange(Trojan.smoke_id)
		local oUnit = Ability.Filters.CloseHurt(self.squad_ai:GetPosition(), iRange, 1)
		if (oUnit ~= nil and oUnit:IsInCombat() and cpu_manager:GetUnitStrength(oUnit) > 150) then
			self.squad_ai:DoSpecialAbilitySquad(Trojan.smoke_id, oUnit:GetSquad())
		end
	end

	if (self.squad_ai:CanDoAbility(Atlas.repair_boost_id)) then
		-- Check if we are not under attack
		if not (self.squad_ai:IsInCombat() or self.squad_ai:WasRecentlyHurt()) then
			-- Check if we do have a target to repair
			if self.m_iTargetForRepair ~= nil then
				-- Check if that target is still valid once we have reached it
				if self.m_iTargetForRepair:IsValid() then
					-- Check if already at high health (normal repair is OK, do not waste the ability - long reload!)
					if self.m_iTargetForRepair:GetHealthPercentage() < 0.8 then
						if distance_sqr(self.squad_ai:GetPosition(), self.m_iTargetForRepair:GetPosition()) < 100 then
							self.squad_ai:DoSpecialAbility(Atlas.repair_boost_id)
							self.m_iTargetForRepair = nil
						end
					else
						self.m_iTargetForRepair = nil
					end
				else
					self.m_iTargetForRepair = nil
				end
			end
		end
	end
end

function TrojanTactic:ValidMove( vDestination )
	
	aitrace("Move Trojan to "..tostring(vDestination.x)..", "..tostring(vDestination.z))
	
	-- Check distance
	self.m_vDestination = Vector3f(vDestination)
	if (distance_sqr(self.squad_ai:GetPosition(), vDestination) > sqr(50)) then
	
		-- Try to jump	
		if (not cpu_manager:JumpBuilder(self.squad_ai, vDestination)) then
			self.squad_ai:DoMove(vDestination)
		end
	else
		self.squad_ai:DoMove(vDestination)
	end
end

function TrojanTactic:Update()

	self:DoAbilities()

	-- Arkhan 01.2006: Check state
	local vSquadPos = self.squad_ai:GetPosition()
	if (self.squad_ai:IsLocked()) then
	
		-- Arkhan 01.2006: Reset destination if squad is locked
   		self.m_vDestination = nil
   		self.m_bBusy = false
   		
		-- Release the flag
		if (self.tagged_flag ~= nil) then
			self.tagged_flag:TagFlagForTrojan( false )
			self.tagged_flag = nil
		end
		return true
   	
   	elseif (self.m_vDestination ~= nil and not self.m_bBusy) then
   	
   		-- Arkhan 01.2006: Make sure that the squad moves to the target position
   		if (self.squad_ai:IsInStateMove()) then
   		
   			if (distance_sqr(cpu_manager.start_pos, vSquadPos) > self.m_iValidRange) then
   			
   				if (cpu_manager.terrain_analyzer:HasThreat(self.m_vDestination, 35)) then
   					self:GoToNextPost()
   				else
   					self.squad_ai:DoMove(self.m_vDestination)
   				end
   				return true
   			end
   		end
   	
   	elseif (distance_sqr(cpu_manager.start_pos, vSquadPos) > self.m_iValidRange and not self.m_bBusy) then
   	
   		-- Arkhan 01.2006: The move command seems invalid and the Trojan should therefore return to a safe place
		self:GoToNextPost()
		return true
	end
   	
   	if (self.tagged_flag == nil and not self.squad_ai:IsInStateMove()) then
   	
   		-- Arkhan 01.2006: Get new job
		self:GoToNextPost()
	end

	return true
end

function TrojanTactic:IsAffectedByMorale()
	return false
end

function TrojanTactic:GoToNextPost()

	-- Try to reach a save position if HQ is attacked
	self.m_bBusy = false
	local vEngineerPos = self.squad_ai:GetPosition()
	if (cpu_manager:HQThreat() or self.squad_ai:WasRecentlyHurt()) then
		local vBasePos = cpu_manager:FindClosestFriendlyBaseOrStrategicPoint(vEngineerPos, cpu_manager.start_pos, true, true)
		if (vBasePos ~= nil) then
			self:ValidMove(vBasePos)
			self.m_iValidRange = 35
			return
		end
	end

	-- Only attempt vehicle repair if we can
	local iClosestDistance = 0
	if (self.squad_ai:CanRepair()) then

		-- Find the closest vehicle that can be repaired
		local oVehicleToRepair = cpu_manager:GetDamagedVehicleInRange()
		if (oVehicleToRepair ~= nil) then
			aitrace("TrojanTactic: Repairing vehicle...")
			self.squad_ai:DoRepairSquad(oVehicleToRepair)
			self.m_vDestination = oVehicleToRepair:GetPosition()
			self.m_bBusy = true
			self.m_iTargetForRepair = oVehicleToRepair
			return
		end
	end

	-- Try to help finish a building
	local oBuildingToFinish = cpu_manager:GetUnfinishedBuildingInRange()
	if (oBuildingToFinish ~= nil) then
		aitrace("TrojanTactic: Help finishing a building...")
		self.squad_ai:DoFinishBuilding(oBuildingToFinish)
		self.m_vDestination = oBuildingToFinish:GetPosition()
		self.m_bBusy = true
		return
	end
				
	-- Only attempt building repair if we can
	if (self.squad_ai:CanRepair()) then
	
		-- Find the closest building that can be repaired
		local oBuildingToRepair = cpu_manager:GetDamagedBuildingInRange()
		if (oBuildingToRepair ~= nil) then
			aitrace("TrojanTactic: Repairing building...")
			self.squad_ai:DoRepairBase(oBuildingToRepair)
			self.m_vDestination = oBuildingToRepair:GetPosition()
			self.m_bBusy = true
			self.m_iTargetForRepair = oBuildingToRepair
			return
		end
	end

	-- Return to home base
	if (distance_sqr(cpu_manager.start_pos, vEngineerPos) > sqr(35)) then
		aitrace("TrojanTactic: Return to home base")
		self:ValidMove(cpu_manager.start_pos)
		return
	end
end
