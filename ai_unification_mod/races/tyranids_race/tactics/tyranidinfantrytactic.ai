------------------------------------------
-- File: 'tyranidinfantrytactic.ai'
-- Edited by Gambit		@ 25.07.2017
-- Edited by Thudmeizer		@ 11.03.2024

class 'TyranidInfantryTactic' (InfantryTactic)

function TyranidInfantryTactic:__init( squad_ai ) super( squad_ai )

	self:SetName("Tyranids Infantry Tactic")
end

TyranidsInfantryAbilities = {}

function TyranidInfantryTactic:AddCommanders()
	table.insert(self.commander, { "tyranids_squad_broodlord", true })
	table.insert(self.commander, { "tyranids_squad_broodlord_advance_sp", true })
	table.insert(self.commander, { "tyranids_squad_hive_tyrant", false })
	table.insert(self.commander, { "tyranids_squad_hive_tyrant_advance_sp", false })
	table.insert(self.commander, { "tyranids_squad_hive_tyrant_ktgm", false })
end

function TyranidInfantryTactic:InitAbilities()

	 if TyranidsInfantryAbilities.bio_plasma_warrior_id == nil then
		TyranidsInfantryAbilities.bio_plasma_warrior_id = cpu_manager.stats:GetAbilityID( "tyranids_bioplasma" )
		TyranidsInfantryAbilities.bio_plasma_fex_id = cpu_manager.stats:GetAbilityID( "tyranids_bioplasma_fex" )
		TyranidsInfantryAbilities.bio_plasma_ufex_id = cpu_manager.stats:GetAbilityID( "tyranids_bioplasma_ufex" )
		TyranidsInfantryAbilities.catalyst_zohan_id = cpu_manager.stats:GetAbilityID( "tyranids_zohan_catalyst" )
	 end
end

function TyranidInfantryTactic:CanOnlyDecap()
	local sSquadName = self.squad_ai:GetSquadName()
	if sSquadName == "tyranids_squad_lictor" or sSquadName == "tyranids_squad_lictor_advance_sp" or sSquadName == "tyranids_squad_ripperswarm" then
		return true
	end
	return false
end

function TyranidInfantryTactic:AlwaysAttack()
	local sSquadName = self.squad_ai:GetSquadName()
	if sSquadName == "tyranids_squad_spore_cluster" or sSquadName == "tyranids_squad_carnifex_skiller"
	or sSquadName == "tyranids_squad_carnifex" or sSquadName == "tyranids_squad_carnifex_uber" then
		return true
	end
	return false
end

function TyranidInfantryTactic:DoAbilities()

	-- Do not perform the abilities if we need to reserve Influence
	-- if TyranidsReserveFaithResource then return end
	
	local sSquadName = self.squad_ai:GetSquadName()
	if sSquadName == "tyranids_squad_zoanthropes" or sSquadName == "tyranids_squad_zoanthropes_advance_sp" then
		Ability.DoAbilityTarget( self.squad_ai, TyranidsInfantryAbilities.catalyst_zohan_id, Ability.Filters.CloseHurt )
	elseif sSquadName == "tyranids_squad_carnifex" then
		Ability.DoAbilityTarget( self.squad_ai, TyranidsInfantryAbilities.bio_plasma_fex_id, Ability.Filters.CloseSquadEnemy, 1 )
	-- elseif sSquadName ==  "tyranids_squad_carnifex_uber" then
	--	Ability.DoAbilityTarget( self.squad_ai, TyranidsInfantryAbilities.bio_plasma_ufex_id, Ability.Filters.CloseSquadEnemy, 1 )
	elseif sSquadName == "tyranids_squad_warrior" or sSquadName == "tyranids_squad_warrior_advance_sp" then
		Ability.DoAbilityTarget( self.squad_ai, TyranidsInfantryAbilities.bio_plasma_warrior_id, Ability.Filters.CloseSquadEnemy, 1 )
	end

	-- Call basic DoAbilities methods
	InfantryTactic.DoAbilities(self)
end


function TyranidInfantryTactic:Upgrade()

	-- Check if we are reinforcing
	if (self.squad_ai:IsReinforcing() or not self.squad_ai:HasUpgradableTrooper()) then
		return
	end

	-- If I am broken, don't upgrade!
	if (self:IsAffectedByMorale() and self.squad_ai:IsBroken()) then
		return
	end	
	
	-- Only upgrade in healthy state
	if (self.squad_ai:GetNumTroopers() < self.squad_ai:GetMaxTroopers() * 0.6 or self.squad_ai:GetHealthPercentage() < 0.5) then
		return
	end

	--[[ Only upgrade in weave enough Influence - plus, return if we must reserve resources for tiering! 
	local iInfluence = resource_manager:GetResourceAmount():Get( ResourceAmount.RT_Faith )
	if iInfluence < 10 or TyranidsReserveFaithResource then
		return
	end]]

	-- Set upgrade direction
	local eUpgradeType = UnitStatsAI.UC_VehicleMed
	if (math.random(1, 2) == 2) then

		-- Figure out my enemy's favourite class
		local oEnemy = cpu_manager:FindClosestEnemyPlayer()
		if (oEnemy ~= nil) then
			eUpgradeType = oEnemy:GetMajorityClassType()
		end
	end

	-- Try to upgrade
	self.squad_ai:DoBestUpgrade(eUpgradeType)
end


function TyranidInfantryTactic:BrokenMorale()
	-- Find closest own bio-structure
	local oBuilding = FindClosestOwnBase(self.squad_ai:GetPosition(), 1024)
	if oBuilding ~= nil then
		self.squad_ai:DoMove(oBuilding:GetPosition())
	end

	-- Increase safe tolerance
	if (self.last_time ~= nil and self.squad_ai:WasAttackedSince(self.last_time))  then
		self.tolerance = self.tolerance + 10
	end
	self.last_time = g_iGMT
	
	-- Check if I have enough morale or health if attached
	if (not self.squad_ai:IsBroken() and self.squad_ai:GetMoralePercentage() > 0.9) then
	
		self.m_eSubStateID = Tactic.StateID.NoState
		self.stateID = Tactic.StateID.NoState
		
		-- Go back in the fray - reset my state
		self.last_time = nil
		Tactic.SetState(self, self:GetState())
	else
		self.m_eSubStateID = self.stateID
	end
end


-- Broken Tyranids should BEST retreat to an army building to restore morale (Synapse). This function returns the closest.
function FindClosestOwnBase( from_pos, min_displacement )
	local min_displacement_sqr = min_displacement * min_displacement
	local best_base = nil
	local best_distance = -1
	local candidate_bases = {}

	-- Get candidate bases
	for base in military_manager:GetBases() do
		if base ~= nil and base:IsValid() and base:IsConstructionDone() then
			local base_pos = base:GetPosition()
			if (distance_sqr( base_pos, from_pos ) <= min_displacement_sqr) then
				local base_info = {}
				base_info.base = base
				base_info.pos = base_pos
				base_info.distance = distance(base_info.pos,from_pos)
				table.insert(candidate_bases,base_info)
			end
		end
	end

	-- Sort candidates so we start with closest
	table.sort(candidate_bases,function(e1,e2) return e1.distance < e2.distance end)
	
	-- Find best
	for i,candidate in candidate_bases do
		local base = candidate.base
		local base_pos = base:GetPosition()
		
		if best_base == nil then
			best_base = base
			best_distance = cpu_manager:GetShortestPathingDistance(base_pos, from_pos)
		elseif (candidate.distance < best_distance or best_distance == -1) then
			local new_distance = cpu_manager:GetShortestPathingDistance(base_pos, from_pos)
			if new_distance < best_distance or best_distance == -1 then
				best_base = base
				best_distance = new_distance
			end
		end
	end
	return best_base
end