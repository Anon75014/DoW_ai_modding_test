----------------------------------------
-- File: 'tsdaemonabilitytactic.ai'
-- Created by Thudmeizer @ 03.02.2009
-- Edited by Gambit @ 26.2.2016

class 'TSDaemonAbilityTactic' (TSInfantryTactic)

TSDaemonAbility = {}

function TSDaemonAbilityTactic:__init( squad_ai ) super( squad_ai )

       self:SetName("TS Daemon Ability Tactic")
end

function TSDaemonAbilityTactic:InitAbilities()

	if (TSDaemonAbility.furious_id == nil) then
	  	 TSDaemonAbility.furious_id = cpu_manager.stats:GetAbilityID( "thousand_sons_furious_charge" )	
	end
end

function TSDaemonAbilityTactic:DoAbilities()

	if self.squad_ai:CanDoAbility( TSDaemonAbility.furious_id ) then
		if (self.squad_ai:IsInCombat() and not self.squad_ai:IsCapturing() and not self.squad_ai:IsBroken()) then
			self.squad_ai:DoSpecialAbility( TSDaemonAbility.furious_id )
		end
	end

end


--------------------------------------------------------------------------------------------------------------------------
-- CORE function override for Daemons' broken morale (retreating), since Daemons must ONLY retreat to "special" safepoints.

function TSDaemonAbilityTactic:BrokenMorale()
	-- Find closest allied Daemon Gate
	local oBuilding = FindClosestAlliedDaemonGateBase(self.squad_ai:GetPosition(), 1024)
	if oBuilding ~= nil then
--print(oBuilding:GetEntity():GetBlueprintName())
		self.squad_ai:DoMove(oBuilding:GetPosition())
	end

	-- Increase safe tolerance
	if (self.last_time ~= nil and self.squad_ai:WasAttackedSince(self.last_time))  then
		self.tolerance = self.tolerance + 10
	end
	self.last_time = g_iGMT
	
	-- Check if I have enough morale or health if attached
	if (not self.squad_ai:IsBroken() and self.squad_ai:GetMoralePercentage() > 0.9) then
	
		self.m_eSubStateID = Tactic.StateID.NoState
		self.stateID = Tactic.StateID.NoState
		
		-- Go back in the fray - reset my state
		self.last_time = nil
		Tactic.SetState(self, self:GetState())
	else
		self.m_eSubStateID = self.stateID
	end
end


-- Broken Tzeentch Daemons should BEST retreat to a Daemon Gate (allied) to restore morale. This function returns the closest.
-- Included option for retreating to allied Chaos Daemons race buildings.
function FindClosestAlliedDaemonGateBase( from_pos, min_displacement )
	local min_displacement_sqr = min_displacement * min_displacement
	local best_base = nil
	local best_distance = -1
	local candidate_bases = {}

	-- Get candidate bases (allied or own)
	for player in cpu_manager.stats:GetPlayerStats() do
		if not (cpu_manager.player_stats:IsEnemy(player) or player:IsPlayerDead()) then
			local race_name = player:GetPlayerRaceName()
			-- Check for TS valid buildings
			if race_name == "thousand_sons_race" then
				for base in player:GetBases() do
					-- Check for valid building
					if (base ~= nil and base:IsValid()) then
						if base:GetEntity():GetBlueprintName() == "thousand_sons_gate" then
							if base:IsConstructionDone() then
								local base_pos = base:GetPosition()
								if (distance_sqr( base_pos, from_pos ) <= min_displacement_sqr) then
									local base_info = {}
									base_info.base = base
									base_info.pos = base_pos
									base_info.distance = distance(base_info.pos,from_pos)
									table.insert(candidate_bases,base_info)
								end
							end
						end
					end
				end
			-- Check for CD valid buildings
			elseif race_name == "deamons_race" then
				for base in player:GetBases() do
					-- Check for valid building
					if (base ~= nil and base:IsValid()) then
						local base_name = base:GetEntity():GetBlueprintName()
						if (base_name ~= "daemon_eye_of_terror" and base_name ~= "daemon_maledictum" and
						base_name ~= "daemon_turret" and base_name ~= "daemon_turret_maledictum") then
							if base:IsConstructionDone() then
								local base_pos = base:GetPosition()
								if (distance_sqr( base_pos, from_pos ) <= min_displacement_sqr) then
									local base_info = {}
									base_info.base = base
									base_info.pos = base_pos
									base_info.distance = distance(base_info.pos,from_pos)
									table.insert(candidate_bases,base_info)
								end
							end
						end
					end
				end
			end
		end
	end

	-- Sort candidates so we start with closest
	table.sort(candidate_bases,function(e1,e2) return e1.distance < e2.distance end)
	
	-- Find best
	for i,candidate in candidate_bases do
		local base = candidate.base
		local base_pos = base:GetPosition()
		
		if best_base == nil then
			best_base = base
			best_distance = cpu_manager:GetShortestPathingDistance(base_pos, from_pos)
		elseif (candidate.distance < best_distance or best_distance == -1) then
			local new_distance = cpu_manager:GetShortestPathingDistance(base_pos, from_pos)
			if new_distance < best_distance or best_distance == -1 then
				best_base = base
				best_distance = new_distance
			end
		end
	end
	return best_base
end
