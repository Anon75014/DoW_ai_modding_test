----------------------------------------
-- File: 'ravenguardthunderhawktactic.ai'
-- Edited by Gambit	@ 15.07.2016
-- Edited by Thudmeizer	@ 04.02.2024

class 'RavenGuardThunderhawkTactic' (RavenGuardSpaceMarineVehicleTactic)

RavenGuardThunderHawk = {}

function RavenGuardThunderhawkTactic:__init( squad_ai ) super( squad_ai )

	self:SetName("Raven Guard Thunderhawk Tactic")
	
	-- Assume thunderhawk just entrenched/retrenched
	self.m_iLastEntrenchTime = g_iGMT
	self.entrenchAttempt = g_iGMT

	-- Get the type we have
	self.isFlyingVersion = self.squad_ai:GetSquadName() == "raven_guard_space_marine_squad_thunderhawk"
	-- Get ID and loaded status for the NEW flying TH, and if it was previously loaded
	if self.isFlyingVersion then
		if TH_FlyingID == nil or self.squad_ai:GetID() ~= TH_FlyingID then
			TH_IsLoaded = false
			TH_FlyingID = self.squad_ai:GetID()
		end
	end

	--Vehicle is a heavy transport. New AI implemented for flying transports.
	self.iTHTransportSlots = 5
	self.iTHUsedTransportSlots = 0
	self.m_iTransportVehicle = 3

	-- Used for the stuck check code for the squads that can jump
	self.initialPosition = self.squad_ai:GetPosition()
end

function RavenGuardThunderhawkTactic:InitAbilities()
	-- Init ability ID's
	if (RavenGuardThunderHawk.land == nil or RavenGuardThunderHawk.takeoff == nil) then
		RavenGuardThunderHawk.land = cpu_manager.stats:GetAbilityID("raven_guard_th_land")
		RavenGuardThunderHawk.takeoff = cpu_manager.stats:GetAbilityID("raven_guard_th_takeoff")
		RavenGuardThunderHawk.missiles = cpu_manager.stats:GetAbilityID("raven_guard_th_missiles")
		RavenGuardThunderHawk.infiltration = cpu_manager.stats:GetAbilityID( "raven_guard_aircraft_infiltration" )
	end
end

--[[
function RavenGuardThunderhawkTactic:NeedRepair()
	return false
end
]]

function RavenGuardThunderhawkTactic:DoAbilities()

	-- Missile Launchers
	if self.isFlyingVersion then
		local iPow = resource_manager:GetResourceAmount():Get( ResourceAmount.RT_Power )
		if self.squad_ai:IsUsingAbility(RavenGuardThunderHawk.missiles) then
			-- Turn off if of low resources
			if iPow < 800 then
				self.squad_ai:DoSpecialAbility(RavenGuardThunderHawk.missiles)
			end
		elseif iPow > 900 then
			self.squad_ai:DoSpecialAbility(RavenGuardThunderHawk.missiles)
		end
	end

	-- Check to make sure if threats are nearby
	if self.squad_ai:IsInCombat() then

		-- If I can infiltrate when enemies are close
		local iPos = self.squad_ai:GetPosition()
		local oTarget = Ability.Filters.CloseEnemy(iPos, 10, 1)
		if oTarget ~= nil and oTarget:IsValid() then
			if (self.squad_ai:CanDoAbility( RavenGuardThunderHawk.infiltration )) then
				self.squad_ai:DoSpecialAbility( RavenGuardThunderHawk.infiltration )
			end
		end
	end
--[[
	-- Transportation code
	if not self.isFlyingVersion and (not self.squad_ai:IsInCombat() and (self:GetState() == "Hold" or not self:IsMoving())) then
		-- Check for nearby squads
		local oFunctor = function(oSquad, iCount)
			return oSquad:GetNumTroopers() > iCount and not ((oSquad:IsInStateMove() or oSquad:IsInCombat()))
		end

		local eSquad = cpu_manager:GetClosestSquad(self.squad_ai:GetPosition(), 20, oFunctor, 6)
		if eSquad ~= nil then
			print(eSquad:GetSquadName())
		end
	end

	print(self.squad_ai:IsIdle())
	print(self.squad_ai:CanUnload())
	print(self.squad_ai:GetID())
]]
	-- Try to entrench first
	self:DoEntrenchAbility()

	-- If TOO damaged, retreat
	if g_iGMT > self.entrenchAttempt + 3 then
		if self.isFlyingVersion and self.squad_ai:GetHealthPercentage() < 0.3 then
			self:SetState(Tactic.States.Retreat)
			Tactic.SetState(self, self:GetState())
			self:BeginRetreatState()
			cpu_manager:DoMove(self.squad_ai, cpu_manager.start_pos, false, "RetreatState Vehicle")
		end
	end

	-- Jump squads' unstuck code call. Put ANYWHERE in the DoAbilities() function
	-- Checks jump-able stuck squads, and force them to jump nearby
	if self.isFlyingVersion then
		if self.squad_ai:CanJump() then
			self:SolveStuckCase()
		end
	end
end

function RavenGuardThunderhawkTactic:DoEntrenchAbility()

	-- Unload troops immediately, since it is not implemented yet
	if not self.isFlyingVersion and self.squad_ai:CanUnload() then
		self.squad_ai:DoUnload()
	end

--[[ 
	-- Don't land/takeoff too fast after last attempt. Disabled, not needed.
	if (g_iGMT < self.m_iLastEntrenchTime + 30) then
		return
	end
]]
	local health = self.squad_ai:GetHealthPercentage()
	
-- Disabled as flier does not land at start_pos due to being held by standard vehicle repair code after retreat. Flier gets repaired regardless at start_pos due to being normal vehicle
--[[
	-- Check if we have to land back at start_pos to be repaired, because of low health
	if self.isFlyingVersion and ((health < 0.5 and not self.squad_ai:IsInCombat()) or health < 0.25) then
		if self.squad_ai:CanDoAbility(RavenGuardThunderHawk.land) and not (cpu_manager.terrain_analyzer:HasThreat(self.squad_ai:GetPosition(), 35) or self.squad_ai:WasRecentlyHurt()) then
			self:SetState(Tactic.States.Retreat)
			Tactic.SetState(self, self:GetState())
			self:BeginRetreatState()
			cpu_manager:DoMove(self.squad_ai, cpu_manager.start_pos, false, "RetreatState Vehicle")

			-- Check for damaged flying vehicle close to start point then attempt to land to get repaired
			local vSquadPos = self.squad_ai:GetPosition()
			local iDistance = distance_sqr(self.target, vSquadPos)
			if (self.m_bNeedRepair and iDistance < sqr(50) and self.squad_ai:WasRecentlyHurt() and distance_sqr(self.target, cpu_manager.start_pos) < 1) then
				self.squad_ai:DoSpecialAbility(RavenGuardThunderHawk.land)
				self.m_iLastEntrenchTime = g_iGMT
				self.entrenchAttempt = g_iGMT
			end
		end
	end

	-- Check for damaged flying vehicle close to start point then attempt to land to get repaired
	local vSquadPos = self.squad_ai:GetPosition()
	local iDistance = distance_sqr(self.target, vSquadPos)
	if self.isFlyingVersion and ((health < 0.5 and not self.squad_ai:IsInCombat()) or health < 0.25) then
		if self.squad_ai:CanDoAbility(RavenGuardThunderHawk.land) and not (cpu_manager.terrain_analyzer:HasThreat(self.squad_ai:GetPosition(), 35) or self.squad_ai:WasRecentlyHurt()) then
			--if (self.m_bNeedRepair and iDistance < sqr(50) and self.squad_ai:WasRecentlyHurt() and distance_sqr(self.target, cpu_manager.start_pos) < 1) then
			if (iDistance < 200) then
				self.squad_ai:DoSpecialAbility(RavenGuardThunderHawk.land)
				self.m_iLastEntrenchTime = g_iGMT
				self.entrenchAttempt = g_iGMT
			end
		end
	end
]]
	-- Check if we must take off to carry on fighting
	if not self.isFlyingVersion and self.squad_ai:CanDoAbility(RavenGuardThunderHawk.takeoff) then
		if self.squad_ai:WasRecentlyHurt() or health > 0.85 or (health > 0.6 and BuildBaseStrategy:HasRelic())
		or cpu_manager.terrain_analyzer:HasThreat(self.squad_ai:GetPosition(), 35) then
			self.squad_ai:DoSpecialAbility(RavenGuardThunderHawk.takeoff)
		end
	end
end

function RavenGuardThunderhawkTactic:Update()

	-- State machine
	if (not VehicleTactic.Update( self )) then
		return false
	end
--[[
	if (self:IsComplete()) then
		return
	end

	-- Check if vehicle can be repaired
	if (self.squad_ai:CanBeRepaired() and self.squad_ai:GetNumTroopers() == 1 and not self.squad_ai:IsReinforcing()) then
	
		-- Set repair states
		if (self.squad_ai:IsRanged() and self.squad_ai:GetHealthPercentage() < 0.2) then
			self.m_bNeedRepair = true
		elseif (not self.squad_ai:IsRanged() and not self.squad_ai:WasRecentlyHurt() and self.squad_ai:GetHealthPercentage() < 0.4) then
			self.m_bNeedRepair = true
		end
	end
	
	-- Check if vehicle needs repair
	if (self.m_bNeedRepair) then
			
		-- Check if vehicle is repaired
		aitrace("Current repair target = "..tostring(self.target.x)..", "..tostring(self.target.z))
		if (self.squad_ai:GetHealthPercentage() > 0.99) then
	        	self.m_bNeedRepair = false
	        	self.hurt_level = 0.6
	    e	nd
	end
	
	if (self.squad_ai:CanJump()) then
		self.tolerance_default = self.squad_ai:GetJumpDistance()
	else
		self.tolerance_default = 100
	end
	
	self:Upgrade()
	
	self:Reinforce()
]]
	self:SyncSubState()
	
	-- Check if ranged vehicle under attack wants to retreat a short distance
	self:Retreat()
	
	if (self.stateID == Tactic.StateID.NoState) then
	
		-- Check dance mode
		if (CpuManager.AISettings.iDancing == 2) then
			self:CheckForDance()
			if (self.stateID == Tactic.StateID.NoState) then
				self:CheckForStealthTroops()
			end
		elseif (CpuManager.AISettings.iDancing == 1 and g_iGMT > self.m_iDancing + 10) then
			self:CheckForDance()
			if (self.stateID == Tactic.StateID.NoState) then
				self:CheckForStealthTroops()
			end
		end
	end
	
	-- Special moves
	self:CloseOnEnemy()
	
	-- Do abilities
	self:InitAbilities()
	self:DoAbilities()
	
	-- Don't update stance if in special substate !
	if (self.stateID == Tactic.StateID.NoState) then
		self:UpdateStance()
	end
	
	return true
end

function RavenGuardThunderhawkTactic:BeginRetreatState()

	-- Check if we're busy
	if self:IsInSubState() then
		return
	end

	-- Check move delay
	if (g_iGMT < self.m_iMoveDelay + 5 and (self:IsMoving() or self.m_bNeedRepair)) then
		Tactic.SetSubState( self, VehicleTactic.HoldState, "Holding" )
		return
	end

	local vSquadPos = self.squad_ai:GetPosition()
	local iDistance = distance_sqr(self.target, vSquadPos)

--[[ 
	-- Try to unload troops
	if (self:UnloadTroops(iDistance)) then
		self.m_iMoveDelay = g_iGMT - 3
		Tactic.SetSubState(self, self.HoldState, "Holding")
		return
	end

	-- Check for damaged vehicles close to start point
	if (self.m_bNeedRepair and iDistance < sqr(50) and not self.squad_ai:WasRecentlyHurt() and
		distance_sqr(self.target, cpu_manager.start_pos) < 1) then
		
		if ((self.squad_ai:IsInStateAttackMove() or self.squad_ai:IsInStateMove()) and not self:IsMoving()) then
			self.squad_ai:DoStop()
			self.m_iMoveDelay = g_iGMT + 15	
		end
		Tactic.SetSubState( self, VehicleTactic.HoldState, "Holding" )
		return
	end
]]
	-- Check distance
	if (iDistance > sqr(50) or not self:IsDefender()) then
	
		-- If we are too far away from the retreat position, then make a basic move
		cpu_manager:DoMove(self.squad_ai, self.target, false, "RetreatState Vehicle")
		
	elseif (iDistance > sqr(25) or self.squad_ai:WasRecentlyHurt()) then
	
		-- If we are in range of the retreat position, then make an attack move
		cpu_manager:DoMove(self.squad_ai, self.target, true, "RetreatState Vehicle")
	else
		self.squad_ai:DoStop()
	end
	self.m_iMoveDelay = g_iGMT

	-- Set holding sub-state
	Tactic.SetSubState( self, VehicleTactic.HoldState, "Holding" )
end

-------------------------------------------------------------------------

--[[ Too complex to create viable aircraft fliers Transportation code.... Doable, but I gave up.
function RavenGuardThunderhawkTactic:ReadyToTransport()
-- Testing....
if true then return true end
	if self.isFlyingVersion then
		return (not self.squad_ai:WasRecentlyHurt() and self.squad_ai:GetHealthPercentage() > 0.4 and
				not self.squad_ai:IsInCombat() and not cpu_manager.terrain_analyzer:HasThreat(self.squad_ai:GetPosition(), 70))
	else
		return (self.iTHUsedTransportSlots < self.iTHTransportSlots and not self.squad_ai:WasRecentlyHurt() and
				self.squad_ai:GetHealthPercentage() > 0.3 and not self.squad_ai:IsInCombat() and
				not cpu_manager.terrain_analyzer:HasThreat(self.squad_ai:GetPosition(), 50))
	end
end

function RavenGuardThunderhawkTactic:LoadSquad(oSquad, iSquadStrength)
	if self.isFlyingVersion then
		if self.squad_ai:CanDoAbility(RavenGuardThunderHawk.land) then
			self.squad_ai:DoSpecialAbility(RavenGuardThunderHawk.land)
		end
	else
		-- Update transport data
		self.m_iLoadedTroopStrength = self.m_iLoadedTroopStrength + iSquadStrength
		self.iTHUsedTransportSlots = self.iTHUsedTransportSlots + (OccupiedSlotsDA[oSquad:GetSquadName()] or 1)
		-- Load squad
		-- print(self.iTHUsedTransportSlots)
		--cpu_manager:DoMove(self.squad_ai, oSquad:GetPosition(), false, "Load troops")
		for oEntity in self.squad_ai:GetEntities() do
			oSquad:DoDefault(oEntity)
			break
		end
		self.m_iMoveDelay = g_iGMT - 3
	end
end

function RavenGuardThunderhawkTactic:UnloadTroops(iDistance)
	-- Check if vehicle has loaded troops
	if self.squad_ai:CanUnload() then
		-- Check if we should unload the troops
		if (self.squad_ai:WasRecentlyHurt() or self.squad_ai:GetHealthPercentage() < 0.4 or self.m_bNeedRepair or
			self.squad_ai:IsInCombat() or (self.squad_ai:IsLocked() and iDistance < sqr(35))) then

			-- Unload all troops
			self.squad_ai:DoStop()
			self.squad_ai:DoUnload()
			self.iTHUsedTransportSlots = 0
			self.m_iLoadedTroopStrength = 0
			return true
		end
		return false
	end
	return false
end
]]

-- Unstuck Code --------------------------------------------------
function RavenGuardThunderhawkTactic:SolveStuckCase()
	local iPosition = self.squad_ai:GetPosition()
	if iPosition.x ~= self.initialPosition.x or iPosition.z ~= self.initialPosition.z then
	-- NOT stuck, update previous position and return, we are all good
		self.initialPosition = iPosition
		return
	end

	-- If we got here, the squad is NOT moving. See if it is simply waiting, or is stuck!
	local state = self.squad_ai:GetTactic():GetState()
	if (self.squad_ai:IsInStateMove() or self.squad_ai:IsInStateAttackMove() or state == "Attack") and not self.squad_ai:IsInCombat()
	and iPosition.x == self.initialPosition.x and iPosition.z == self.initialPosition.z then
	-- STUCK!!!!! Run the unstuck code
		self:ForceSquadJumpNear(iPosition)
	end
	-- Update previous position anyway
	self.initialPosition = self.squad_ai:GetPosition()
end

function RavenGuardThunderhawkTactic:ForceSquadJumpNear(pos)
	local iPos = self.squad_ai:GetPosition()
	local vJumpPosition = self.squad_ai:GetPosition()
	local jumpDist = self.squad_ai:GetJumpDistance()
	local jumpDistSqr = jumpDist * jumpDist
	local vDir = cpu_manager:GetDirectionToEnemy(pos)
	-- First, try an unstuck jump TOWARDS the enemy 
	-- Try to jump somewhere near, perform 30 checks in total, for a viable position
	for i = 1, 12 do
		-- Create a jump position
		vJumpPosition.x = pos.x + vDir.x * math.random(10, jumpDist)
		vJumpPosition.z = pos.z + vDir.z * math.random(10, jumpDist)
		-- Check if target position is in range and if unit is able to jump to target position
		local iDistanceSqr = distance_sqr(vJumpPosition, iPos)
		if iDistanceSqr < jumpDistSqr and self.squad_ai:CanJumpToPosition(vJumpPosition) then
			-- Jump to position
			self.squad_ai:DoJump(vJumpPosition)
			self.last_jump = g_iGMT
			self.m_iLastGatherMove = self.last_jump - 10
			return
		end
	end
	-- Then try any random nearby place, as a secondary option
	for i = 1, 18 do
		-- Create a jump position
		vJumpPosition.x = pos.x + 0.7 * math.random(-jumpDist, jumpDist)
		vJumpPosition.z = pos.z + 0.7 * math.random(-jumpDist, jumpDist)
		-- Check if target position is in range and if unit is able to jump to target position
		local iDistanceSqr = distance_sqr(vJumpPosition, iPos)
		if iDistanceSqr < jumpDistSqr and self.squad_ai:CanJumpToPosition(vJumpPosition) then
			-- Jump to position
			self.squad_ai:DoJump(vJumpPosition)
			self.last_jump = g_iGMT
			self.m_iLastGatherMove = self.last_jump - 10
			return
		end
	end
end